\section{Introduction}

Existing implementations of call-by-need take care in \emph{packaging} a delayed
computation, or \emph{thunk}, by building a closure with an array binding all
free variables \cite{jonesstg,boquist1997grin}. The overhead induced by
this operation is well known, and one reason for avoiding thunks wherever
possible \cite{johnsson1984efficient}. The key insight of our \emph{Cactus
Environment ($\mathcal{CE}$) Machine} is that we can minimize this overhead by
constructing the computation and environment to save our spot, like a
\emph{bookmark}.

As an example, consider the application $t \; t'$. In existing call-by-need
implementations, e.g., the STG machine, a closure with a flat environment will be
constructed for $t'$.  This has a time and memory cost proportional to the
number of free variables of $t'$ \footnote{in some implementations, these will
be lambda lifted to be formal parameters, but the principle is the same}.  We
minimize this packaging cost by saving our place in a shared environment, which
results in requiring only two machine words (and two instructions) for the
thunk: one for the code pointer, and one for the environment pointer. One way to
think about our approach is that it is \emph{lazier} about lazy evaluation: in
the case that $t'$ is unneeded, the work to package it in a thunk is entirely
wasted. In the spirit of lazy evaluation, we attempt to minimize this
potentially unnecessary work.  

The main contributions of the paper are:
\begin{itemize}
\item A big-step and small-step semantics that formalize the notion of a shared
environment for call-by-need evaluation using an explicitly shared environment
(Section~\ref{sec:calc}).
\item A simple compiled implementation of the small-step semantics with a 
preliminary evaluation that shows performance comparable to existing
implementations (Sections~\ref{sec:impl} and~\ref{sec:eval}).
\end{itemize}

Section~\ref{sec:back} reviews relevant background material, and
Section~\ref{sec:env} discusses the current landscape of environment
representations, highlighting the opportunity for combining shared environments
with lazy evaluation.  We then provide some intuition for why this combination
is desirable, and formalize the connection between call-by-need evaluation and
shared environments in a calculus (Section~\ref{sec:calc}).
Section~\ref{sec:mach} uses the calculus to derive a novel abstract machine, the
$\mathcal{CE}$ machine, explains how $\mathcal{CE}$ uses the shared environment
in a natural way to implement lazy evaluation, and gives its formal semantics.
We then describe a straightforward implementation of $\mathcal{CE}$ in
Section~\ref{sec:impl}, extended with machine literals and primitive operations,
compiling directly to native code. We evaluate the implementation in
Section~\ref{sec:eval}, showing that it is capable of performing comparably to
existing implementations, despite lacking several common optimizations, and
discuss the results. We discuss related work, the limitations of our approach,
and some ideas for future work in Section~\ref{sec:disc}, and conclude the
paper in Section~\ref{sec:conc}.


