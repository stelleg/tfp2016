\section{Introduction}

Call-by-need evaluation is notoriously slow, and replaced by strict evaluation
where possible\cite{burn1986strictness}. There are a number of contributing
factors for why this is the case, but the one we focus on in this paper is the
cost of delayed computations, or \emph{thunks}. The goal of this work will be to
minimize the this cost. The key idea of the \emph{Cactus Environment Machine} is
to use a shared environment to minimize the cost of thunks, and thus implement
call-by-need efficiently. 

We view the current situation as follows: Existing implementations take care in
\emph{packaging} a thunk. For example, a graph reduction machine has to
"construct the graph" for the right hand side of an application to delay the
computation \cite{landin1964mechanical}. One way to view the work in this paper
is that instead of packaging a thunk, we construct the computation so that we
may save our spot, like a \emph{bookmark}, so that we can later return to
compute the delayed computation. 

As an illustrating example, consider the application $t \; t'$. In existing call
by-need implementations, e.g. the STG machine, a closure with a flat environment
will be constructed for $t'$.  This has a time and memory cost proportional to
the number of free variables for $t'$ \footnote{in some implementations, these
will be lambda lifted to be formal parameters, but the principle is the same}.
The approach we take is to minimize this packaging cost by saving our place in a
shared environment, which results in only requiring two machine words (and two
instructions) for the thunk: one for the code pointer, and one for the
environment pointer. One way to think about our approach is that it is
\emph{lazier} about lazy evaluation: in the case that $t'$ is unneeded, the work
to package it in a thunk is entirely wasted. In the spirit of lazy evaluation,
we attempt to minimize this potentially unnecessary work.  

The main contributions of the paper are:
\begin{itemize}
\item A big-step and small-step semantics that formalize the notion of a shared
environment for call-by-need evaluation using an explicitly shared environment
(Section~\ref{sec:calc}).
\item A simple compiled implementation of the small-step semantics and
preliminary evaluation, which shows performance comparable to existing
implementations (Sections~\ref{sec:impl} and~\ref{sec:eval}).
\end{itemize}

Section~\ref{sec:back} reviews relevant background material, and
Section~\ref{sec:env} discusses the current landscape of environment
representations, highlighting the opportunity for combining shared environments
with lazy evaluation.  We then provide some intuition for why this combination
is desirable, and formalize the connection between call-by-need evaluation and
shared environments in a calculus (Section~\ref{sec:calc}).
Section~\ref{sec:mach} uses the calculus to derive a novel abstract machine, the
$\mathcal{CE}$ machine, explains how $\mathcal{CE}$ uses the shared environment
in a natural way to implement lazy evaluation, and gives its formal semantics.
We then describe a straightforward implementation of $\mathcal{CE}$ in
Section~\ref{sec:impl}, extended with machine literals and primitive operations,
compiling directly to native code. We evaluate the implementation in
Section~\ref{sec:eval}, showing that it is capable of performing competitively,
despite lacking several common optimizations, and discuss the results. We
conclude by discussing related work, the limitations of our approach, and give
some ideas for future work in Section~\ref{sec:disc}, and conclude the paper in
Section~\ref{sec:conc}.


