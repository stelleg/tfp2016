\subsection{Results} \label{sec:res}

Figure~\ref{fig:res} gives the benchmark results.  In general, we are
outperformed by GHC, sometimes significantly, and generally outperform UHC. We
spend the rest of the section analyzing these performance differences.

Even with optimizations as an option turned off (\texttt{-O0}), there are still
a significant number of optimizations that are used by GHC and/or UHC that
aren't available to the $\mathcal{CE}$ machine. For example:

\begin{itemize}
\item Register allocation
\item Known applications
\item Explicit recursion
\item Global functions
\item Strictness analysis
\item Liveness analysis
\item Literal unboxing
\end{itemize}

\begin{figure*}
\centering
\begin{tabular}{l | l | l | l | l | l}
& $\mathcal{CE}$ & GHC -O0 & UHC -O0 & GHC -O3 & UHC -O3 \\
\hline
<<<<<<< HEAD
\texttt{exp3 8} & 1.530 & 1.176 & 3.318 & 1.038 & 2.286 \\
\texttt{tak 16 8 0} & .366 & .146 & 1.510 & .006 & 1.416 \\
\texttt{primes 1500} & .256 & .272 & 1.518 & .230 & 1.532 \\
\texttt{queens 9} & .206 & .050 & .600 & .012 & .598 \\
\texttt{fib 35} & 2.234 & .872 & 10.000 & .110 & 8.342 \\
\texttt{expexp 8} & .598 & 3.766 & 4.302 & 3.988 & 3.980 \\
\texttt{digits-of-e1 1000} & 3.576 & 1.274 & 21.938 & .118 & 22.010 \\
\texttt{digits-of-e2 1000} & .404 & .792 & 3.430 & .372 & 3.278 \\
\texttt{fannkuch 8} & .560 & .084 & 2.184 & .048 & 2.196 \\
\end{tabular}
\caption{Benchmark Results. Measurement is wall clock time, all units are
seconds. Times averaged over 5 runs}
\label{fig:res}
\end{figure*}

We expect that with the addition of these optimizations, the $\mathcal{CE}$
machine will become significantly more competitive. We discuss how some of these
optimizations can be applied to the $\mathcal{CE}$ machine in
Section~\ref{sec:disc}.

We look more closely at two of the benchmarks: \texttt{tak}, where we perform
quite poorly compared to optimized GHC, and \texttt{expexp}, where we perform
quite well. For \texttt{tak}, the poor performance is due to the
following factors: 

\begin{itemize}
\item \textbf{Y combinator:} \texttt{tak} is largely a benchmark of recursion.
Because recursion is implemented with a Y combinator, we perform poorly. This
should be alleviated with CFA-based techniques, similar to those used in ~\cite{rozas1992taming}. 
\item \textbf{Register allocation:} This is also a case where a proper register
allocator really helps. By passing the arguments of the \texttt{tak} function in
registers, GHC avoids a lot of heap thrashing.
\end{itemize}

The \texttt{expexp} program is one in which we are more competitive for the following reasons:
\begin{itemize}
\item \textbf{Partial application:} While most of the church operators are
supercombinators, the application of them creates significant amounts of partial
applications. For existing machines this causes expensive closures, but for the
$\mathcal{CE}$ machine, these closures are cheap to create.  
\item \textbf{Pure lambda term:} Many of the optimizations listed above that
are such an advantage on most programs lose their advantage here. For example,
strictness analysis and global function knowledge do little for this kind of
program. There is no recursion and no data types, removing that advantage as
well. 

\end{itemize}

\subsection{The Cost of the Cactus}

One big question, is what is the cost of the variable lookup. Recall that
variable lookup is linear in the index of the variable, following pointers until
the index is zero.

The answer, as one might guess, is that linear variable lookup cost is very
lage. Without any optimizations. For example, on the queens benchmark, variable
lookup took roughly $80-90\%$ of the runtime, as measured by profiling. Much
of that cost was for lookups of supercombinators, however, so for the benchmarks
above we added the inlining mentioned in the previous section. Still, even with
this simple optimization, variable lookup still takes roughly $50\%$ of the
runtime. There is some variation across benchmarks, but this is a rough
approximation for the average cost. We discuss how this cost could be addressed
in future work in Section~\ref{sec:disc}.


